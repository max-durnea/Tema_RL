#!/usr/bin/python3
import sys
import struct
import wrapper
import threading
import time
from wrapper import recv_from_any_link, send_to_link, get_switch_mac, get_interface_name

cam_table = {}
priority = 0
name_to_id = {}  # store in format {"r-0-1":1}
interfacesDict = {}  # store in format {id:info}
port_host_ext = {}

# Spanning Tree Protocol constants and state holders
STP_MULTICAST_MAC = b'\x01\x80\xc2\x00\x00\x00'
PORT_PRIORITY_DEFAULT = 128  # IEEE 802.1D default port priority (Section 17.13)
PORT_COST_100_MBPS = 19  # IEEE 802.1D-2004 Table 17-3 (100 Mbps link cost)
MAX_AGE_SECONDS = 40  # IEEE 802.1D-2004 recommends max age <= 40s
HELLO_TIME_SECONDS = 2  # IEEE 802.1D-2004 default hello time
FORWARD_DELAY_SECONDS = 4  # IEEE 802.1D-2004 minimum forward delay

stp_lock = threading.Lock()
bridge_id = None
bridge_id_int = None
root_bridge_id = None
root_bridge_id_int = None
root_path_cost = 0
root_port = None
port_states = {}
port_roles = {}
port_costs = {}
best_bpdus = {}
ppdu_sequence = 0
# Debug

def print_cam_table_contents():
    for k, v in cam_table.items():
        k_str = k[0]
        print(f"For {k_str} VLAN {k[1]} port {v}")


def parse_ethernet_header(data):
    # Unpack the header fields from the byte array
    #dest_mac, src_mac, ethertype = struct.unpack('!6s6sH', data[:14])
    dest_mac = data[0:6]
    src_mac = data[6:12]

    # Extract ethertype. Under 802.1Q, this may be the bytes from the VLAN TAG
    ether_type = (data[12] << 8) + data[13]

    vlan_id = -1
    vlan_tci = -1
    # Check for VLAN tag (0x8200 in network byte order is b'\x82\x00')
    if ether_type == 0x8200:
        vlan_tci = int.from_bytes(data[14:16], byteorder='big')
        vlan_id = vlan_tci & 0x0FFF  # extract the 12-bit VLAN ID
        ether_type = (data[16] << 8) + data[17]

    return dest_mac, src_mac, ether_type, vlan_id, vlan_tci

def create_vlan_tag(ext_id, vlan_id):
    # Use EtherType = 8200h for our custom 802.1Q-like protocol.
    # PCP and DEI bits are used to extend the original VID.
    #
    # The ext_id should be the sum of all nibbles in the MAC address of the
    # host attached to the _access_ port. Ignore the overflow in the 4-bit
    # accumulator.
    #
    # NOTE: Include these 4 extensions bits only in the check for unicast
    #       frames. For multicasts, assume that you're dealing with 802.1Q.
    return struct.pack('!H', 0x8200) + \
           struct.pack('!H', ((ext_id & 0xF) << 12) | (vlan_id & 0x0FFF))




def forward_frame(interface, data):
    send_to_link(interface, len(data), data)

def check_mac_in_cam_table(mac):
    return cam_table.get(mac, -1)

def parse_switch_config(filename):
    ports = {}
    priority = None

    with open(filename, 'r') as f:
        lines = [line.strip() for line in f if line.strip()]

    if not lines:
        raise ValueError("Config file is empty")

    priority = int(lines[0])

    for line in lines[1:]:
        parts = line.split()
        if len(parts) != 2:
            raise ValueError(f"Invalid line in config: {line}")
        iface, val = parts
        if val.upper() == "T":
            ports[iface] = {"mode": "trunk"}
        else:
            ports[iface] = {"mode": "access", "vlan": int(val)}

    return priority, ports


def is_multicast(mac_bytes):
    # Check if the least significant bit of the first byte is set
    return (mac_bytes[0] & 0x01) == 1


# VLAN helpers adapted for Poli VLAN tagging
def calc_suma_nibbles(mac_str):
    mac_nou = mac_str.replace(":", "")
    suma = 0
    for ch in mac_nou:
        suma += int(ch, 16)
    return suma % 16


def should_check_extension(vlan_tci, dest_mac_str):
    first_octet = int(dest_mac_str.split(":")[0], 16)
    is_multicast_mac = (first_octet & 1) == 1
    return vlan_tci != -1 and not is_multicast_mac


def ext_id_matches(vlan_tci, dest_mac_str, expected_ext):
    if not should_check_extension(vlan_tci, dest_mac_str):
        return True
    ext_id_from_frame = (vlan_tci >> 12) & 0xF
    if expected_ext is None:
        return True
    match = ext_id_from_frame == expected_ext
    if not match:
        print(f"[EXT-MISMATCH] frame_ext={ext_id_from_frame} expected_ext={expected_ext} dest_mac={dest_mac_str} vlan_tci=0x{vlan_tci:04x}")
    else:
        print(f"[EXT-MATCH] frame_ext={ext_id_from_frame} expected_ext={expected_ext} dest_mac={dest_mac_str}")
    return match


def verifica_mac_table(src_mac_str, vlan, port):
    key = (src_mac_str, vlan)
    if cam_table.get(key) != port:
        cam_table[key] = port
        print(f"[CAM] Learned {src_mac_str} on VLAN {vlan} -> port {port}")

    return True

'''
TODO: Create HPDU 
Hello Protocol Data Units (HPDU). Este un pachet trimis la fiecare secundă de
fiecare switch. Îl vom folosi ca formă de verificare a faptului că un link este activ. În
această implementare doar vom trimite aceste cadre, nu ne interesează
funcționalitatea de marcare a unui link ca fiind nefuncțional. Acesta este trimis pe
toate porturile, si cele trunk, si cele catre hosts. Pachetul HPDU va fi un simplu
cadru de ethernet (type 0x0800) care contine ca date un byte cu valoarea 255.
Vom folosi MAC-ul destinatie ff:ff:ff:ff:ff:ff

TODO: Poli Protocol Data Units (PPDU). Vor conține trei informații importante:
identificatorul switch-ului rădăcină (root bridge ID - 64 biți), identificatorul switch-ului
expeditor (sender bridge ID - 64 biți) și costul drumului până la rădăcină (root path
cost - 64 biți). Switch-ul rădăcină (root bridge) este switch-ul cu identificatorul cel mai
mic.
Structura cadrelor PPDU. Cadrele PPDU folosesc encapsularea 802.2 Logical Link Control
header. Mai jos putem vedea structura unui cadru PPDU.
| DST_MAC | SRC_MAC |LLC_LENGTH | LLC_HEADER | PPDU_HEADER | PPDU_CONFIG
| 6 bytes | 6 | 2 | 3 | 8 | 31
LLC_LENGTH este dimensiunea totala a cadrului, inclusiv dimensiunea PPDU.
LLC_HEADER are urmatoarea structura:
| DSAP | SSAP | CONTROL
Pentru a identifica protocolul PPDU, DSAP si SSAP vor fi 0x42. Pentru control vom pune
0x03
Structura Poli PPDU_HEADER este următoarea:
Protocol ID | Protocol Version | PPDU Type | Sequence Number
| 2 bytes | 1 | 1 | 4
Protocol ID - Vom folosi 0x0002 pentru PPDU Protocol
● Protocol Version - Vom folosi 0
● PPDU Type (1 byte): Vom folosi 0x80
● Sequence Number (4 bytes): Numărul de secvență. Fiecare cadru PPDU va avea
acest număr incrementat. Vom porni numărul de secvență de la 0. Valoarea va fi
modulo 100. Astfel, primul cadru trimis la prima cuantă de timp va avea numărul de
secvență 0, al doilea va avea numărul de secvență 1, al 100-lea va avea numărul de
secvență 99, iar al 101-lea va avea numărul de secvență 0.
Structura PPDU_CONFIG este următoarea:
flags (1 byte) | Root Bridge ID (8 bytes) | root path cost (4bytes) | Bridge id (8 bytes)| port id (2 bytes)| message age (2 bytes)| max age (2 bytes)| hello time (2 bytes)| forward delay (2 bytes)

Vom presupune fiecare link ca fiind de 100 Mbps, costul pe link va fi conform celor
descris în curs pentru STP (pentru switch-uri cu legături normale, nu rapide). Este
folosit in calculul root path cost.
● bridge id va fi calculat conform descrierii din curs. Prioritatea este disponibilă în
config.
● Max age va fi setat pe maximul posibil din specificatia de 802.1D-2004
● Hello Time va fi setat pe valoarea recomandata din 802.1D-2004
● Forward Delay va fi setat pe valoarea minima din 802.1D-2004
● port id este construit conform standardului 802.1D. Vom folosi varianta implicită
definită în standard.
● flags il setam pe 0
● message age este setat pe 0
Nu uitati, in networking folosim Big Endian.


NOTE Pentru a fi punctat acest subpunct, cadrele trebuie să respecte indicațiile de mai sus.
Pentru fiecare valoare din cadru care nu este exact specificată în enunț (e.g., pentru cele
unde se specifică că valoarea este conform 802.1D-2004), va trebui să argumentați
decizia și să includeți o referință. Fie un link, fie un PDF în arhivă în directorul sources.
Sursa trebuie să includă locația exactă în document, fie prin pagină, fie prin numele
secțiunii etc. Checker-ul verifică doar funcționalitatea, nu și respectarea cerințelor de fond.
'''
def create_hpdu():
    """
    Create Hello Protocol Data Unit (HPDU)
    - Destination MAC: ff:ff:ff:ff:ff:ff (broadcast)
    - Source MAC: switch MAC
    - EtherType: 0x0800
    - Data: single byte with value 255
    """
    dest_mac = b'\xff\xff\xff\xff\xff\xff'
    src_mac = get_switch_mac()
    ether_type = struct.pack('!H', 0x0800)
    data = b'\xff'  # single byte with value 255
    
    frame = dest_mac + src_mac + ether_type + data
    
    # Pad to minimum Ethernet frame size (60 bytes without FCS)
    # Frame is currently 6 + 6 + 2 + 1 = 15 bytes, need 60 bytes minimum
    min_size = 60
    if len(frame) < min_size:
        frame += b'\x00' * (min_size - len(frame))

    return frame


def parse_ppdu(data):
    """
    Parse a received PPDU frame into its constituent fields.
    """
    minimum_length = 6 + 6 + 2 + 3 + 8 + 35
    if len(data) < minimum_length:
        return None

    llc_length = struct.unpack('!H', data[12:14])[0]
    dsap, ssap, control = struct.unpack('!BBB', data[14:17])
    if llc_length != 46 or dsap != 0x42 or ssap != 0x42 or control != 0x03:
        return None

    offset = 17
    protocol_id, protocol_version, ppdu_type, sequence_number = struct.unpack('!HBBI', data[offset:offset + 8])
    offset += 8

    if protocol_id != 0x0002 or protocol_version != 0 or ppdu_type != 0x80:
        return None

    flags = struct.unpack('!B', data[offset:offset + 1])[0]
    offset += 1
    root_bridge_id = data[offset:offset + 8]
    offset += 8
    root_path_cost = struct.unpack('!I', data[offset:offset + 4])[0]
    offset += 4
    sender_bridge_id = data[offset:offset + 8]
    offset += 8
    port_id = struct.unpack('!H', data[offset:offset + 2])[0]
    offset += 2
    message_age, max_age, hello_time, forward_delay = struct.unpack('!HHHH', data[offset:offset + 8])

    return {
        "sequence_number": sequence_number,
        "flags": flags,
        "root_bridge_id": root_bridge_id,
        "root_path_cost": root_path_cost,
        "sender_bridge_id": sender_bridge_id,
        "port_id": port_id,
        "message_age": message_age,
        "max_age": max_age,
        "hello_time": hello_time,
        "forward_delay": forward_delay,
    }


def get_port_identifier(interface_id):
    """
    Construct the 16-bit port identifier (port priority + port number).
    IEEE 802.1D encodes the port priority in the most significant byte.
    """
    port_number = (interface_id + 1) & 0xFF
    return (PORT_PRIORITY_DEFAULT << 8) | port_number


def initialize_stp_state(priority_value, interfaces_list):
    """
    Initialise global STP state for the switch.
    """
    global bridge_id, bridge_id_int, root_bridge_id, root_bridge_id_int
    global root_path_cost, root_port, port_states, port_roles, port_costs
    global best_bpdus, ppdu_sequence

    with stp_lock:
        bridge_id = create_bridge_id(priority_value, get_switch_mac())
        bridge_id_int = int.from_bytes(bridge_id, byteorder='big')
        root_bridge_id = bridge_id
        root_bridge_id_int = bridge_id_int
        root_path_cost = 0
        root_port = None
        ppdu_sequence = 0

        port_states = {}
        port_roles = {}
        port_costs = {}
        best_bpdus = {}

        for interface_id in interfaces_list:
            port_states[interface_id] = "forwarding"
            port_roles[interface_id] = "designated"
            port_costs[interface_id] = PORT_COST_100_MBPS


def port_is_forwarding(interface_id):
    with stp_lock:
        return port_states.get(interface_id, "forwarding") == "forwarding"


def recompute_spanning_tree():
    """
    Recalculate the root bridge and per-port roles/states based on the best
    BPDUs received so far.
    """
    global root_bridge_id, root_bridge_id_int, root_path_cost, root_port

    with stp_lock:
        if bridge_id_int is None:
            return

        self_baseline = (bridge_id_int, 0, bridge_id_int, 0, 0)
        best_candidate = self_baseline
        best_candidate_port = None

        for interface_id, info in best_bpdus.items():
            vector = info["vector"]
            port_cost = port_costs.get(interface_id, PORT_COST_100_MBPS)
            candidate = (
                vector[0],
                vector[1] + port_cost,
                vector[2],
                vector[3],
                get_port_identifier(interface_id),
            )
            if candidate < best_candidate:
                best_candidate = candidate
                best_candidate_port = interface_id

        if best_candidate_port is None:
            # We are the root bridge
            root_bridge_id = bridge_id
            root_bridge_id_int = bridge_id_int
            root_path_cost = 0
            root_port = None
            for interface_id in port_states:
                port_roles[interface_id] = "designated"
                port_states[interface_id] = "forwarding"
            return

        root_bridge_id_int = best_candidate[0]
        root_bridge_id = root_bridge_id_int.to_bytes(8, byteorder='big')
        root_path_cost = best_candidate[1]
        root_port = best_candidate_port

        for interface_id in port_states:
            if interface_id == root_port:
                port_roles[interface_id] = "root"
                port_states[interface_id] = "forwarding"
                continue

            neighbor_vector = best_bpdus.get(interface_id, {}).get("vector")
            local_vector = (
                root_bridge_id_int,
                root_path_cost,
                bridge_id_int,
                get_port_identifier(interface_id),
            )

            if neighbor_vector and neighbor_vector < local_vector:
                port_roles[interface_id] = "alternate"
                port_states[interface_id] = "blocking"
            else:
                port_roles[interface_id] = "designated"
                port_states[interface_id] = "forwarding"


def handle_received_ppdu(interface_id, data):
    """
    Process a PPDU frame received on a given interface.
    """
    parsed = parse_ppdu(data)
    if not parsed:
        return

    root_id_int = int.from_bytes(parsed["root_bridge_id"], byteorder='big')
    sender_id_int = int.from_bytes(parsed["sender_bridge_id"], byteorder='big')
    vector = (
        root_id_int,
        parsed["root_path_cost"],
        sender_id_int,
        parsed["port_id"],
    )

    should_recompute = False
    with stp_lock:
        current = best_bpdus.get(interface_id)
        if current is None or vector < current["vector"]:
            best_bpdus[interface_id] = {
                "vector": vector,
            }
            should_recompute = True

    if should_recompute:
        recompute_spanning_tree()


def collect_ppdu_transmissions():
    """
    Gather PPDU frames that need to be sent based on current STP state.
    """
    transmissions = []
    global ppdu_sequence
    with stp_lock:
        if bridge_id is None or root_bridge_id is None:
            return transmissions

        for interface_id, role in port_roles.items():
            if role != "designated":
                continue
            if interface_id not in interfacesDict:
                continue

            sequence = ppdu_sequence
            transmissions.append(
                (
                    interface_id,
                    sequence,
                    root_bridge_id,
                    root_path_cost,
                    bridge_id,
                )
            )
            ppdu_sequence = (ppdu_sequence + 1) % 100

    return transmissions


def send_hpdu_on_all_ports(interfaces):
    """Send HPDU on all configured ports"""
    hpdu_frame = create_hpdu()
    for interface in interfaces:
        if interface in interfacesDict:
            forward_frame(interface, hpdu_frame)

def function_on_different_thread(interfaces):
    """Periodic task: send HPDU and PPDU every second"""
    interfaces_list = list(interfaces)
    while True:
        time.sleep(1)
        send_hpdu_on_all_ports(interfaces_list)
        transmissions = collect_ppdu_transmissions()
        for interface_id, sequence, root_id, path_cost, bridge_id_bytes in transmissions:
            frame = create_ppdu(
                root_id,
                path_cost,
                bridge_id_bytes,
                get_port_identifier(interface_id),
                sequence,
            )
            forward_frame(interface_id, frame)
# new
def create_ppdu(root_bridge_id, root_path_cost, own_bridge_id, port_id, sequence_number):
    """
    Create Poli Protocol Data Unit (PPDU) for STP
    
    Frame structure:
    DST_MAC (6) | SRC_MAC (6) | LLC_LENGTH (2) | LLC_HEADER (3) | PPDU_HEADER (8) | PPDU_CONFIG (31)
    Total payload: 3 + 8 + 31 = 42 bytes
    
    Args:
        root_bridge_id: 8 bytes - Root bridge identifier
        root_path_cost: 4 bytes (int) - Cost to reach root
        own_bridge_id: 8 bytes - This switch's bridge ID
        port_id: 2 bytes (int) - Port identifier
        sequence_number: int (0-99) - Sequence number modulo 100
    """
    # Ethernet header
    dest_mac = b'\x01\x80\xc2\x00\x00\x00'  # STP multicast address
    src_mac = get_switch_mac()
    
    # LLC payload: LLC_HEADER (3) + PPDU_HEADER (8) + PPDU_CONFIG (35) = 46 bytes
    llc_length = struct.pack('!H', 46)
    
    # LLC_HEADER (3 bytes)
    dsap = 0x42
    ssap = 0x42
    control = 0x03
    llc_header = struct.pack('!BBB', dsap, ssap, control)
    
    # PPDU_HEADER (8 bytes)
    protocol_id = 0x0002
    protocol_version = 0
    ppdu_type = 0x80
    seq_num = sequence_number % 100  # modulo 100
    ppdu_header = struct.pack('!HBBI', protocol_id, protocol_version, ppdu_type, seq_num)
    
    # PPDU_CONFIG (35 bytes)
    # flags (1) | Root Bridge ID (8) | root path cost (4) | Bridge ID (8) | 
    # port id (2) | message age (2) | max age (2) | hello time (2) | forward delay (2)
    flags = 0
    message_age = 0
    max_age = MAX_AGE_SECONDS  # 802.1D-2004: max is 40 seconds (20-40 range)
    hello_time = HELLO_TIME_SECONDS  # 802.1D-2004: recommended is 2 seconds (1-10 range)
    forward_delay = FORWARD_DELAY_SECONDS  # 802.1D-2004: min is 4 seconds (4-30 range)
    
    ppdu_config = struct.pack('!B', flags)  # flags (1 byte)
    ppdu_config += root_bridge_id  # Root Bridge ID (8 bytes)
    ppdu_config += struct.pack('!I', root_path_cost)  # root path cost (4 bytes)
    ppdu_config += own_bridge_id  # Bridge ID (8 bytes)
    ppdu_config += struct.pack('!H', port_id)  # port id (2 bytes)
    ppdu_config += struct.pack('!H', message_age)  # message age (2 bytes)
    ppdu_config += struct.pack('!H', max_age)  # max age (2 bytes)
    ppdu_config += struct.pack('!H', hello_time)  # hello time (2 bytes)
    ppdu_config += struct.pack('!H', forward_delay)  # forward delay (2 bytes)
    
    # Assemble frame
    frame = dest_mac + src_mac + llc_length + llc_header + ppdu_header + ppdu_config
    
    # Pad to minimum Ethernet frame size (60 bytes)
    # Exact size should already meet the Ethernet minimum (60 bytes without FCS)
    # but keep padding logic for safety.
    min_size = 60
    if len(frame) < min_size:
        frame += b'\x00' * (min_size - len(frame))
    
    return frame

def create_bridge_id(priority, mac_address):
    """
    Create 8-byte bridge ID from priority and MAC address
    Bridge ID = priority (2 bytes) + MAC address (6 bytes)
    
    Args:
        priority: int (0-65535)
        mac_address: 6 bytes
    
    Returns:
        8 bytes representing the bridge ID
    """
    return struct.pack('!H', priority) + mac_address

def main():
    # init returns the max interface number. Our interfaces
    # are 0, 1, 2, ..., init_ret value + 1
    switch_id = sys.argv[1]
    priority, ports_config = parse_switch_config(f"configs/switch{switch_id}.cfg")
    num_interfaces = wrapper.init(sys.argv[2:])
    interfaces = range(0, num_interfaces)
    for interface in interfaces:
        int_real = get_interface_name(interface)
        name_to_id[int_real] = interface
    print(ports_config)
    print(priority)
    print(switch_id)
    for name, info in ports_config.items():
        if name in name_to_id:
            idx = name_to_id[name]
            interfacesDict[idx] = info
        else:
            raise ValueError(f"Interface {name} not found in wrapper")

    print("# Starting switch with id {}".format(switch_id), flush=True)
    print("[INFO] Switch MAC", ':'.join(f'{b:02x}' for b in get_switch_mac()))
    # print the interface table
    print("\n=== Port Configuration Table ===")
    for idx, info in interfacesDict.items():
        print(f"Port {idx} ({get_interface_name(idx)}): {info}")
    print("================================\n")

    initialize_stp_state(priority, list(interfacesDict.keys()))

    # Start thread for sending HPDU every second
    t = threading.Thread(target=function_on_different_thread, args=(interfaces,))
    t.daemon = True  # Allow program to exit even if thread is running
    t.start()

    # Printing interface names
    for i in interfaces:
        print(get_interface_name(i))

    while True:
        # Note that data is of type bytes([...]).
        # b1 = bytes([72, 101, 108, 108, 111])  # "Hello"
        # b2 = bytes([32, 87, 111, 114, 108, 100])  # " World"
        # b3 = b1[0:2] + b[3:4].
        interface, data, length = recv_from_any_link()

        dest_mac, src_mac, ethertype, vlan_id, vlan_tci = parse_ethernet_header(data)
        if ethertype == 0x0800 and data[0] == 255:
            # Received HPDU
            print(f"Received HPDU on interface {interface}")
            continue

        # Check if interface is configured
        if interface not in interfacesDict:
            print(f"Warning: Received frame on unconfigured interface {interface}")
            if dest_mac == STP_MULTICAST_MAC:
                handle_received_ppdu(interface, data)
            continue

        if dest_mac == STP_MULTICAST_MAC:
            handle_received_ppdu(interface, data)
            continue

        if not port_is_forwarding(interface):
            print(f"Port {interface} is blocking; dropping data frame")
            continue

        print(f"Frame received on interface {interface} with mode {interfacesDict[interface]['mode']}")
        print(interfacesDict)
        #interface_mode = interfacesDict[interface]["mode"]
        vlan_tag = (data[12] << 8) + data[13]
        print(f"ethertype: {hex(vlan_tag)}")
        dest_mac_str = ':'.join(f'{b:02x}' for b in dest_mac)
        src_mac_str = ':'.join(f'{b:02x}' for b in src_mac)
        if(vlan_tag == 0x8200):
            # am primit de pe trunk
            verifica_mac_table(src_mac_str, vlan_id, interface)
            print_cam_table_contents()
            #Try forward the frame
            dest_interface = check_mac_in_cam_table((dest_mac_str, vlan_id))
            # trimitem pentru toate interfetele din acelasi vlan si trunkuri
            if dest_interface == -1:
                for i in interfaces:
                    if i != interface:
                        if i not in interfacesDict:
                            continue
                        if not port_is_forwarding(i):
                            continue
                        if interfacesDict[i]["mode"] == "access" and interfacesDict[i]["vlan"] == vlan_id:
                            expected_ext = port_host_ext.get(i)
                            if not ext_id_matches(vlan_tci, dest_mac_str, expected_ext):
                                continue
                            new_data = data[:12] + data[16:]
                            forward_frame(i, new_data)
                        elif interfacesDict[i]["mode"] == "trunk":
                            forward_frame(i, data)
            # am gasit destinatia in tabela, daca e trunk trimitem asa cum e daca e access scoatem tagul
            else:
                if not port_is_forwarding(dest_interface):
                    print(f"Destination port {dest_interface} blocking; dropping frame")
                    continue
                if interfacesDict[dest_interface]["mode"] == "access":
                    expected_ext = port_host_ext.get(dest_interface)
                    if not ext_id_matches(vlan_tci, dest_mac_str, expected_ext):
                        print("Dropping frame: VLAN extension mismatch for access port")
                        continue
                    new_data = data[:12] + data[16:]
                    forward_frame(dest_interface, new_data)
                elif interfacesDict[dest_interface]["mode"] == "trunk":
                    forward_frame(dest_interface, data)

            # Note. Adding a VLAN tag can be as easy as
            # tagged_frame = data[0:12] + create_vlan_tag(5, 10) + data[12:]

            print(f'Destination MAC: {dest_mac_str}')
            print(f'Source MAC: {src_mac_str}')
            print(f'EtherType: {ethertype}')

            print("Received frame of size {} on interface {}".format(length, interface), flush=True)

            # TODO: Implement forwarding with learning
            # TODO: Implement VLAN support
            # TODO: Implement STP support

            # data is of type bytes.
            # send_to_link(i, length, data)
        else:
            # Received from access port - get VLAN ID from interface config
            vlan_id = interfacesDict[interface]["vlan"]
            verifica_mac_table(src_mac_str, vlan_id, interface)
            ext_id_src = calc_suma_nibbles(src_mac_str)
            port_host_ext[interface] = ext_id_src
            print_cam_table_contents()
            dest_interface = check_mac_in_cam_table((dest_mac_str, vlan_id))
            dest_is_multicast = is_multicast(dest_mac)
            dest_ext = calc_suma_nibbles(dest_mac_str) if not dest_is_multicast else None
            if dest_interface == -1:
                # Flood
                for i in interfaces:
                    if i != interface:
                        if i not in interfacesDict:
                            continue
                        if not port_is_forwarding(i):
                            continue
                        if interfacesDict[i]["mode"] == "access" and interfacesDict[i]["vlan"] == vlan_id:
                            if not dest_is_multicast:
                                expected_ext = port_host_ext.get(i)
                                if expected_ext is not None and expected_ext != dest_ext:
                                    continue
                            forward_frame(i, data)
                        elif interfacesDict[i]["mode"] == "trunk":
                            # need to add vlan tag with source ext_id
                            new_data = data[:12] + create_vlan_tag(ext_id_src, vlan_id) + data[12:]
                            forward_frame(i, new_data)
            else:
                if not port_is_forwarding(dest_interface):
                    print(f"Destination port {dest_interface} blocking; dropping frame")
                    continue
                if interfacesDict[dest_interface]["mode"] == "access":
                    if not dest_is_multicast:
                        expected_ext = port_host_ext.get(dest_interface)
                        if expected_ext is not None and expected_ext != dest_ext:
                            print("Dropping frame: VLAN extension mismatch for learned destination")
                            continue
                    forward_frame(dest_interface, data)
                elif interfacesDict[dest_interface]["mode"] == "trunk":
                    tagged_data = data[:12] + create_vlan_tag(ext_id_src, vlan_id) + data[12:]
                    forward_frame(dest_interface, tagged_data)
        print()
            

if __name__ == "__main__":
    main()
 

